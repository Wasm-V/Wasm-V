#!/usr/bin/env python3
"""
FILENAME: execution/vulnerability_tester.py
DESCRIPTION: Automated vulnerability testing for WASM binaries
Compares execution between vulnerable and patched versions
"""

import json
import shutil
import git
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, asdict
import tempfile
import subprocess
from concurrent.futures import ThreadPoolExecutor, as_completed

import sys
sys.path.append(str(Path(__file__).parent.parent))

from .wasm_executor import WasmExecutor, ExecutionTrace, ExecutionStatus
from lookup.project_cve_lookup import ProjectCVE
from compilation.wasm_compiler import WasmCompiler

@dataclass
class VulnerabilityTest:
    """Represents a vulnerability test case"""
    cve_id: str
    project_name: str
    vulnerable_binary: Path
    patched_binary: Optional[Path]
    test_inputs: List[Dict[str, Any]]
    vulnerable_trace: Optional[ExecutionTrace]
    patched_trace: Optional[ExecutionTrace]
    vulnerability_confirmed: bool
    test_metadata: Dict[str, Any]
    
    def to_dict(self):
        result = asdict(self)
        result['vulnerable_binary'] = str(self.vulnerable_binary)
        if self.patched_binary:
            result['patched_binary'] = str(self.patched_binary)
        return result

class VulnerabilityTester:
    """Automated vulnerability testing system"""
    
    def __init__(self, compiled_wasm_dir: Path, output_dir: Path = None):
        self.compiled_wasm_dir = Path(compiled_wasm_dir)
        self.output_dir = output_dir or Path("data/vulnerability_tests")
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        self.executor = WasmExecutor(self.output_dir / "traces")
        self.compiler = WasmCompiler(self.output_dir / "patched_binaries")
        
        # Test input generation strategies
        self.input_generators = {
            'buffer_overflow': self._generate_buffer_overflow_inputs,
            'integer_overflow': self._generate_integer_overflow_inputs,
            'format_string': self._generate_format_string_inputs,
            'path_traversal': self._generate_path_traversal_inputs,
            'sql_injection': self._generate_sql_injection_inputs,
            'generic': self._generate_generic_inputs
        }
    
    def test_all_vulnerabilities(self, cves: List[ProjectCVE]) -> List[VulnerabilityTest]:
        """Test all compiled vulnerabilities"""
        tests = []
        
        for cve in cves:
            vulnerable_binary = self._find_vulnerable_binary(cve)
            if not vulnerable_binary:
                continue
            
            # Try to compile patched version
            patched_binary = self._compile_patched_version(cve)
            
            # Generate test inputs based on vulnerability type
            test_inputs = self._generate_test_inputs(cve)
            
            # Create test case
            test = VulnerabilityTest(
                cve_id=cve.cve_id,
                project_name=cve.source_project.name,
                vulnerable_binary=vulnerable_binary,
                patched_binary=patched_binary,
                test_inputs=test_inputs,
                vulnerable_trace=None,
                patched_trace=None,
                vulnerability_confirmed=False,
                test_metadata={
                    'vulnerability_type': self._classify_vulnerability_type(cve),
                    'severity': cve.severity,
                    'cwe_ids': cve.cwe_ids
                }
            )
            
            # Execute tests
            test = self._execute_vulnerability_test(test)
            tests.append(test)
        
        # Save results
        self._save_test_results(tests)
        return tests
    
    def _find_vulnerable_binary(self, cve: ProjectCVE) -> Optional[Path]:
        """Find the compiled vulnerable binary"""
        project_name = cve.source_project.name
        cve_id = cve.cve_id
        
        # Common naming patterns (our compiler uses project_cve_cve format)
        patterns = [
            f"{project_name}_{cve_id}_{cve_id}.wasm",  # Our actual format
            f"{project_name}_{cve_id}.wasm",
            f"{project_name}.wasm",
            f"{cve_id}.wasm"
        ]
        
        # Search in subdirectories too (our binaries are often in project directories)
        for pattern in patterns:
            # Check root level
            binary_path = self.compiled_wasm_dir / pattern
            if binary_path.exists():
                return binary_path
            
            # Check in subdirectories
            for wasm_file in self.compiled_wasm_dir.glob(f"**/{pattern}"):
                return wasm_file
        
        # Fallback: search for any .wasm file with project name and CVE ID
        for wasm_file in self.compiled_wasm_dir.glob("**/*.wasm"):
            filename = wasm_file.name.lower()
            if (project_name.lower() in filename and 
                (cve_id.lower() in filename or cve_id.replace('-', '_').lower() in filename)):
                return wasm_file
        
        # Last fallback: any .wasm file with project name
        for wasm_file in self.compiled_wasm_dir.glob("**/*.wasm"):
            if project_name.lower() in wasm_file.name.lower():
                return wasm_file
        
        return None
    
    def _compile_patched_version(self, cve: ProjectCVE) -> Optional[Path]:
        """Compile the patched (fixed) version of the project"""
        if not cve.fixed_commit:
            return None
        
        try:
            # Clone repository to temporary directory
            with tempfile.TemporaryDirectory() as temp_dir:
                repo_dir = Path(temp_dir) / "repo"
                
                # Clone the repository
                repo = git.Repo.clone_from(cve.repository_url, repo_dir)
                
                # Checkout the fixed commit
                repo.git.checkout(cve.fixed_commit)
                
                # Attempt compilation
                project_config = {
                    'source_directory': repo_dir,
                    'release': True,
                    'optimize': True
                }
                
                vulnerability_data = {
                    'id': f"{cve.cve_id}_patched",
                    'language': cve.source_project.language,
                    'vulnerability_type': 'patched',
                    'severity': cve.severity
                }
                
                result = self.compiler.compile_project(
                    f"{cve.source_project.name}_patched",
                    vulnerability_data,
                    project_config
                )
                
                if result.wasm_path and result.wasm_path.exists():
                    return result.wasm_path
        
        except Exception as e:
            print(f"Failed to compile patched version for {cve.cve_id}: {e}")
        
        return None
    
    def _classify_vulnerability_type(self, cve: ProjectCVE) -> str:
        """Classify vulnerability type from CVE description"""
        description = (cve.description + " " + " ".join(cve.cwe_ids)).lower()
        
        # Classification based on keywords
        if any(word in description for word in ['buffer overflow', 'buffer overrun', 'heap overflow']):
            return 'buffer_overflow'
        elif any(word in description for word in ['integer overflow', 'integer underflow']):
            return 'integer_overflow'
        elif any(word in description for word in ['format string', 'printf']):
            return 'format_string'
        elif any(word in description for word in ['path traversal', 'directory traversal']):
            return 'path_traversal'
        elif any(word in description for word in ['sql injection']):
            return 'sql_injection'
        elif any(word in description for word in ['use after free', 'double free']):
            return 'memory_corruption'
        else:
            return 'generic'
    
    def _generate_test_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate test inputs based on vulnerability type"""
        vuln_type = self._classify_vulnerability_type(cve)
        
        if vuln_type in self.input_generators:
            return self.input_generators[vuln_type](cve)
        else:
            return self.input_generators['generic'](cve)
    
    def _generate_buffer_overflow_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate inputs to trigger buffer overflow"""
        return [
            {
                'type': 'long_string',
                'args': ['A' * 1000],
                'description': 'Long string input to trigger buffer overflow'
            },
            {
                'type': 'format_string',
                'args': ['%s%s%s%s%s%s%s%s'],
                'description': 'Format string attack'
            },
            {
                'type': 'binary_data',
                'args': ['\\x41' * 500],
                'description': 'Binary data overflow'
            }
        ]
    
    def _generate_integer_overflow_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate inputs to trigger integer overflow"""
        return [
            {
                'type': 'large_number',
                'args': ['2147483647'],  # MAX_INT
                'description': 'Maximum integer value'
            },
            {
                'type': 'negative_large',
                'args': ['-2147483648'],  # MIN_INT
                'description': 'Minimum integer value'
            },
            {
                'type': 'overflow_math',
                'args': ['4294967295'],  # MAX_UINT
                'description': 'Unsigned integer overflow'
            }
        ]
    
    def _generate_format_string_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate format string attack inputs"""
        return [
            {
                'type': 'format_attack',
                'args': ['%x%x%x%x%x%x%x%x'],
                'description': 'Format string memory disclosure'
            },
            {
                'type': 'format_write',
                'args': ['%n%n%n%n'],
                'description': 'Format string write attempt'
            }
        ]
    
    def _generate_path_traversal_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate path traversal inputs"""
        return [
            {
                'type': 'path_traversal',
                'args': ['../../../etc/passwd'],
                'description': 'Unix path traversal'
            },
            {
                'type': 'windows_traversal',
                'args': ['..\\..\\..\\windows\\system32\\config\\sam'],
                'description': 'Windows path traversal'
            }
        ]
    
    def _generate_sql_injection_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate SQL injection inputs"""
        return [
            {
                'type': 'sql_injection',
                'args': ["'; DROP TABLE users; --"],
                'description': 'Basic SQL injection'
            },
            {
                'type': 'union_injection',
                'args': ["' UNION SELECT * FROM information_schema.tables --"],
                'description': 'Union-based SQL injection'
            }
        ]
    
    def _generate_generic_inputs(self, cve: ProjectCVE) -> List[Dict[str, Any]]:
        """Generate generic test inputs"""
        return [
            {
                'type': 'empty',
                'args': [''],
                'description': 'Empty input'
            },
            {
                'type': 'null',
                'args': ['\\x00'],
                'description': 'Null byte input'
            },
            {
                'type': 'long_input',
                'args': ['A' * 1000],
                'description': 'Long input string'
            },
            {
                'type': 'special_chars',
                'args': ['<>"\\"&%$#@!'],
                'description': 'Special characters'
            }
        ]
    
    def _execute_vulnerability_test(self, test: VulnerabilityTest) -> VulnerabilityTest:
        """Execute vulnerability test with various inputs"""
        
        # Analyze the binary first
        binary_analysis = self.executor.analyze_wasm_binary(test.vulnerable_binary)
        
        # Try different execution strategies
        execution_successful = False
        
        for input_data in test.test_inputs:
            if execution_successful:
                break
            
            # Try with different entry points
            entry_points = binary_analysis.get('main_candidates', ['main'])
            if not entry_points:
                entry_points = [None]  # Try without explicit function
            
            for entry_point in entry_points:
                try:
                    # Execute vulnerable version
                    vulnerable_trace = self.executor.execute_wasm_with_inputs(
                        test.vulnerable_binary,
                        function_name=entry_point,
                        args=input_data.get('args', []),
                        timeout=30
                    )
                    
                    # Execute patched version if available
                    patched_trace = None
                    if test.patched_binary:
                        patched_trace = self.executor.execute_wasm_with_inputs(
                            test.patched_binary,
                            function_name=entry_point,
                            args=input_data.get('args', []),
                            timeout=30
                        )
                    
                    # Always save the trace if execution was successful
                    if vulnerable_trace.status == ExecutionStatus.SUCCESS:
                        test.vulnerable_trace = vulnerable_trace
                        execution_successful = True
                    
                    # Save patched trace if available
                    if patched_trace and patched_trace.status == ExecutionStatus.SUCCESS:
                        test.patched_trace = patched_trace
                    
                    # Compare results for vulnerability confirmation
                    if self._analyze_execution_difference(vulnerable_trace, patched_trace):
                        test.vulnerability_confirmed = True
                        break
                    
                    # Even if no patched version, check if vulnerable version shows signs
                    elif vulnerable_trace.vulnerability_triggered:
                        test.vulnerability_confirmed = True
                        break
                    
                    # If we have a successful execution, that's good enough to continue
                    if execution_successful:
                        break
                
                except Exception as e:
                    print(f"Execution failed for {test.cve_id}: {e}")
                    continue
        
        return test
    
    def _analyze_execution_difference(self, vulnerable_trace: ExecutionTrace, 
                                    patched_trace: Optional[ExecutionTrace]) -> bool:
        """Analyze if there's a significant difference indicating vulnerability"""
        
        if not patched_trace:
            return vulnerable_trace.vulnerability_triggered
        
        # Compare execution results
        differences = []
        
        # Different exit codes
        if vulnerable_trace.exit_code != patched_trace.exit_code:
            differences.append("exit_code")
        
        # Different execution status
        if vulnerable_trace.status != patched_trace.status:
            differences.append("status")
        
        # Vulnerable version crashed/trapped
        if vulnerable_trace.trap_info and not patched_trace.trap_info:
            differences.append("trap")
        
        # Significant output differences
        if len(vulnerable_trace.stderr) > len(patched_trace.stderr) * 2:
            differences.append("stderr_size")
        
        return len(differences) > 0
    
    def _save_test_results(self, tests: List[VulnerabilityTest]):
        """Save vulnerability test results"""
        results_file = self.output_dir / "vulnerability_test_results.json"
        
        results = {
            'test_summary': {
                'total_tests': len(tests),
                'confirmed_vulnerabilities': sum(1 for t in tests if t.vulnerability_confirmed),
                'successful_executions': sum(1 for t in tests if t.vulnerable_trace is not None)
            },
            'tests': [test.to_dict() for test in tests]
        }
        
        with open(results_file, 'w') as f:
            json.dump(results, f, indent=2, default=str)
        
        print(f"Vulnerability test results saved to {results_file}")